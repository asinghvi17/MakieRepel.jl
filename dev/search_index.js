var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MakieRepel]","category":"page"},{"location":"api/#MakieRepel.dist-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.dist","text":"dist(a::VecTypes{2}, b::VecTypes{2})\n\nReturns the Euclidean distance (2-distance) between the points in an efficient way.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.intersects-NTuple{4, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.intersects","text":"intersects(a_origin::VecTypes{2}, a_widths::VecTypes{2}, b_origin::VecTypes{2}, b_widths::VecTypes{2})\n\nTests whether the two rectangles a and b intersect, returns boolean. Edges are considered to be within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.intersects-Union{Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Any}} where N","page":"API","title":"MakieRepel.intersects","text":"intersects(origin::VecTypes{N}, widths::VecTypes{N}, point::VecTypes{N}) where N\n\nTests whether the point lies within the rectangle specified by origin and widths; returns a boolean. Edges are considered to be within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.repel_from_points","page":"API","title":"MakieRepel.repel_from_points","text":"repel_from_points(\n    points::AbstractVector{<: Makie.VecTypes{2}}, boxes::AbstractVector{<: Rect2}, axisbbox::Rect2, niters = 10000; \n    padding = 4, x = true, y = true, halign = 0.5, valign = 0.5, data_radius = 5, selfpoint_radius = 3, \n    attraction = 1.9e-2, box_repulsion = 1.1e-2, point_repulsion = 0.99e-2\n)::Vector{<: VecTypes{2, Float64}} # representing origins of bboxes\n\nArguments\n\npoints: The base points of data, in pixel space.\nboxes: The bounding boxes of the texts, in pixel space.\naxisbbox: The bounding box of the axis, usually Rect2f(Point2f(0), widths(scene.px_area[])). Used to ensure that text stays within the axis.\nniters: The number of iterations for which to optimize.  We don't test for convergence, so the loop will run for this many iterations every time.\n\nKeyword arguments\n\npadding: The padding around each box (usually in pixels).\nx: Whether to repel in the x direction.\ny: Whether to repel in the y direction.\nhalign: The horizontal alignment of the centroid of a box.\nvalign: The vertical alignment of the centroid of a box.\ndata_radius: The radius around each data point to be kept clear.\nselfpoint_radius: The radius around the data point associated with the annotation to be kept clear.  Usually less than data_radius.\nattraction: The attractive force between a box and its associated point.\nbox_repulsion: The repulsive force between boxes.\npoint_repulsion: The repulsive force between boxes and data points.\n\n\n\n\n\n","category":"function"},{"location":"api/#MakieRepel.repulsivelabels!-Tuple","page":"API","title":"MakieRepel.repulsivelabels!","text":"repulsivelabels(text::Vector{<: AbstractString}, positions::Vector{Point2f})\n\nImplements repulsive labels a la ggrepel.\n\nAttributes to tune repulsion\n\npadding: The padding around each box (usually in pixels).\nx: Whether to repel in the x direction.\ny: Whether to repel in the y direction.\nhalign: The horizontal alignment of the centroid of a box.\nvalign: The vertical alignment of the centroid of a box.\ndata_radius: The radius around each data point to be kept clear.\nselfpoint_radius: The radius around the data point associated with the annotation to be kept clear.  Usually less than data_radius.\nattraction: The attractive force between a box and its associated point.\nbox_repulsion: The repulsive force between boxes.\npoint_repulsion: The repulsive force between boxes and data points.\n\nExtended help\n\nAvailable attributes and their defaults\n\nAvailable attributes and their defaults for MakieCore.Combined{MakieRepel.repulsivelabels!} are: \n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.repulsivelabels-Tuple","page":"API","title":"MakieRepel.repulsivelabels","text":"repulsivelabels(text::Vector{<: AbstractString}, positions::Vector{Point2f})\n\nImplements repulsive labels a la ggrepel.\n\nAttributes to tune repulsion\n\npadding: The padding around each box (usually in pixels).\nx: Whether to repel in the x direction.\ny: Whether to repel in the y direction.\nhalign: The horizontal alignment of the centroid of a box.\nvalign: The vertical alignment of the centroid of a box.\ndata_radius: The radius around each data point to be kept clear.\nselfpoint_radius: The radius around the data point associated with the annotation to be kept clear.  Usually less than data_radius.\nattraction: The attractive force between a box and its associated point.\nbox_repulsion: The repulsive force between boxes.\npoint_repulsion: The repulsive force between boxes and data points.\n\nExtended help\n\nAvailable attributes and their defaults\n\nAvailable attributes and their defaults for MakieCore.Combined{MakieRepel.repulsivelabels} are: \n\n  attraction        0.07f0\n  box_repulsion     0.072f0\n  cycle             [:color]\n  data_radius       5\n  font              :regular\n  fonts             Attributes with 1 entry:\n  regular => FTFont (family = TeX Gyre Heros Makie, style = Regular)\n  fontsize          14\n  halign            0.5\n  linecolor         :black\n  linestyle         :solid\n  linevisible       true\n  linewidth         1.0\n  marker            :square\n  markercolor       :black\n  markersize        5\n  niters            10000\n  padding           10\n  point_repulsion   0.051f0\n  selfpoint_radius  7.5\n  textalign         (:left, :bottom)\n  textcolor         :black\n  textrotation      0.0f0\n  valign            0.5\n  x                 true\n  y                 true\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-NTuple{4, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(\n    a_origin::VecTypes{2}, a_widths::VecTypes{2}, \n    b_origin::VecTypes{2}, b_widths::VecTypes{2}; \n    k = 10000, x = true, y = true, halign = 0.5, valign = 0.5\n)\n\nRepels the centroids of the two given rectangle specifications a and b away from each other by Hooke's law. Returns the repulsion exerted by b on a.\n\nIf the rectangles intersect, their repulsion is multiplied by 5.  If they do not intersect, it is muttiplied by 0.01.\n\nhalign and valign control the alignment of the centroid within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(a_origin::VecTypes{2}, a_widths::VecTypes{2}, point::VecTypes{2})\n\nReturns the spring-force repulsion between the centroid of the given rectangle and the point.\n\nhalign and valign control the alignment of the centroid within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(a::VecTypes{2}, b::VecTypes{2}; k = 0.01, x = true, y = true)\n\nReturns the repulsive force exerted on a by b, using Hooke's law: F = k⋅(a⃗-b⃗).\n\nx and y represent whether to move in the x or y directions.\n\n\n\n\n\n","category":"method"},{"location":"manipulation/#Figuring-out-good-values","page":"Finding good parameters","title":"Figuring out good values","text":"","category":"section"},{"location":"manipulation/","page":"Finding good parameters","title":"Finding good parameters","text":"To figure out good values, you can use the provided, interactive interface:","category":"page"},{"location":"manipulation/","page":"Finding good parameters","title":"Finding good parameters","text":"using CairoMakie # hide\nCairoMakie.activate!(type=\"svg\") # hide\nusing CairoMakie, MakieRepel\n# to interact, use GLMakie or WGLMakie instead\nfig = Figure(resolution = (1000, 1000))\nmtcars = RDatasets.dataset(\"datasets\", \"mtcars\")\nmtpoints = Point2f.(mtcars.WT, mtcars.MPG)\n\nax, sc = scatter(fig[1, 1], mtpoints)\n# NB: always set `xautolimits = false, yautolimits = false` in plots.\ntp = text!(ax, mtcars.Model; position = mtpoints, align = (:center, :center), xautolimits = false, yautolimits = false)\n\nsg = SliderGrid(fig[2, 1],\n    (label = \"Attraction\", range = LinRange(0f0, 2f-2, 100), startvalue = 2f-3),\n    (label = \"Box repulsion\", range = LinRange(0f0, 2f-2, 100), startvalue = 5f-3),\n    (label = \"Point repulsion\", range = LinRange(0f0, 2f-2, 100), startvalue = 5f-3),\n    (label = \"Data point radius\", range = LinRange(0, 20, 20), startvalue = 5f-3),\n    (label = \"Iterations\", range = LinRange(1000, 11000, 100), startvalue = 5000),\n    ;\n    tellheight= true,\n    tellwidth = false\n)\n\n\nnew_boxes = lift(getproperty.(sg.sliders, :value)..., ax.scene.px_area, tp.plots[1].plots[1][1]) do attraction, box_repulsion, point_repulsion, data_radius, niters, pxarea, text_glyphcollections\n    pixel_mtpoints = Point2f.(Makie.project.((Makie.camera(ax.scene),), :data, :pixel, mtpoints))# .- (origin(ax.scene.px_area[]),)\n    boxes = Makie.boundingbox.(text_glyphcollections, Makie.to_ndim.(Point3f, tp.plots[1].plots[1].position[], 0), fill(Quaternionf(0,0,0,0), length(tp.plots[1].plots[1][1][]))) .|> Rect2f\n    repellable_boxes = Rect2f.(origin.(boxes) .+ pixel_mtpoints, widths.(boxes))\n    repel_from_points(pixel_mtpoints, repellable_boxes, Rect2f(Point2f(0), widths(pxarea)), niters; padding = 15, attraction, box_repulsion, point_repulsion, data_radius)\nend\n\non(new_boxes) do new_boxes\n    tp.position[] = Point2f.(Makie.project.((Makie.camera(ax.scene),), :pixel, :data, new_boxes))\nend\nnotify(new_boxes)\n\nlinesegments!(ax, @lift(collect(Iterators.flatten(zip(mtpoints, $(tp.position))))), inspectable = false, xautolimits = false, yautolimits = false)\n\nfig\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MakieRepel","category":"page"},{"location":"#MakieRepel","page":"Home","title":"MakieRepel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MakieRepel is a re-implementation of ggrepel in Julia, for Makie!  Basically, it repels text from its associated point, the rest of the points in the axis, and from the axis sides.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: download-9)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Finding good parameters page to see how this works!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Eventually, this will all be wrapped in a recipe, but for now you need to do this by hand.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MakieRepel.repel_from_points","category":"page"}]
}
