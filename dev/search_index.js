var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MakieRepel]","category":"page"},{"location":"api/#MakieRepel.dist-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.dist","text":"dist(a::VecTypes{2}, b::VecTypes{2})\n\nReturns the Euclidean distance (2-distance) between the points in an efficient way.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.intersects-NTuple{4, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.intersects","text":"intersects(a_origin::VecTypes{2}, a_widths::VecTypes{2}, b_origin::VecTypes{2}, b_widths::VecTypes{2})\n\nTests whether the two rectangles a and b intersect, returns boolean. Edges are considered to be within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.intersects-Union{Tuple{N}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T}, Tuple{Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Union{Tuple{Vararg{T, N}}, StaticArraysCore.StaticArray{Tuple{N}, T, 1}} where T, Any}} where N","page":"API","title":"MakieRepel.intersects","text":"intersects(origin::VecTypes{N}, widths::VecTypes{N}, point::VecTypes{N}) where N\n\nTests whether the point lies within the rectangle specified by origin and widths; returns a boolean. Edges are considered to be within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-NTuple{4, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(\n    a_origin::VecTypes{2}, a_widths::VecTypes{2}, \n    b_origin::VecTypes{2}, b_widths::VecTypes{2}; \n    k = 10000, x = true, y = true, halign = 0.5, valign = 0.5\n)\n\nRepels the centroids of the two given rectangle specifications a and b away from each other by Hooke's law. Returns the repulsion exerted by b on a.\n\nIf the rectangles intersect, their repulsion is multiplied by 5.  If they do not intersect, it is muttiplied by 0.01.\n\nhalign and valign control the alignment of the centroid within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(a_origin::VecTypes{2}, a_widths::VecTypes{2}, point::VecTypes{2})\n\nReturns the spring-force repulsion between the centroid of the given rectangle and the point.\n\nhalign and valign control the alignment of the centroid within the rectangle.\n\n\n\n\n\n","category":"method"},{"location":"api/#MakieRepel.spring_repel-Tuple{Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T, Union{Tuple{T, T}, StaticArraysCore.StaticArray{Tuple{2}, T, 1}} where T}","page":"API","title":"MakieRepel.spring_repel","text":"spring_repel(a::VecTypes{2}, b::VecTypes{2}; k = 0.01, x = true, y = true)\n\nReturns the repulsive force exerted on a by b, using Hooke's law: F = k⋅(a⃗-b⃗).\n\nx and y represent whether to move in the x or y directions.\n\n\n\n\n\n","category":"method"},{"location":"manipulation/#Figuring-out-good-values","page":"Finding good parameters","title":"Figuring out good values","text":"","category":"section"},{"location":"manipulation/","page":"Finding good parameters","title":"Finding good parameters","text":"To figure out good values, you can use the provided, interactive interface:","category":"page"},{"location":"manipulation/","page":"Finding good parameters","title":"Finding good parameters","text":"using CairoMakie, MakieRepel\n# to interact, use GLMakie or WGLMakie instead\nfig = Figure(resolution = (1300, 1300))\nmtcars = RDatasets.dataset(\"datasets\", \"mtcars\")\nmtpoints = Point2f.(mtcars.WT, mtcars.MPG)\n\nax, sc = scatter(fig[1, 1], mtpoints)\n# NB: always set `xautolimits = false, yautolimits = false` in plots.\ntp = text!(ax, mtcars.Model; position = mtpoints, align = (:center, :center), xautolimits = false, yautolimits = false)\n\nsg = SliderGrid(fig[2, 1],\n    (label = \"Attraction\", range = LinRange(0f0, 1f-2, 100), startvalue = 2f-3),\n    (label = \"Box repulsion\", range = LinRange(0f0, 1f-2, 100), startvalue = 5f-3),\n    (label = \"Point repulsion\", range = LinRange(0f0, 1f-2, 100), startvalue = 5f-3),\n    (label = \"Iterations\", range = LinRange(1000, 11000, 100), startvalue = 5000),\n    ;\n    tellheight= true,\n    tellwidth = false\n)\n\nnew_boxes = lift(getproperty.(sg.sliders, :value)..., ax.scene.px_area) do attraction, box_repulsion, point_repulsion, niters, pxarea\n    pixel_mtpoints = Point2f.(Makie.project.((Makie.camera(ax.scene),), :data, :pixel, mtpoints))# .- (origin(ax.scene.px_area[]),)\n    repel_from_points(pixel_mtpoints, repellable_boxes, ax.scene.px_area[], niters; padding = 5, attraction, box_repulsion, point_repulsion)\nend\n\nfig\n\n\nboxes = Makie.boundingbox.(tp.plots[1].plots[1][1][], Makie.to_ndim.(Point3f, tp.plots[1].plots[1].position[], 0), fill(Quaternionf(0,0,0,0), length(tp.plots[1].plots[1][1][]))) .|> Rect2f\n\nrepellable_boxes = Rect2f.(origin.(boxes) .+ pixel_mtpoints, widths.(boxes))\n\non(new_boxes) do new_boxes\n    tp.position[] = Point2f.(Makie.project.((Makie.camera(ax.scene),), :pixel, :data, new_boxes))\nend\nnotify(new_boxes)\n\nlinesegments!(ax, @lift(collect(Iterators.flatten(zip(mtpoints, $(tp.position))))), inspectable = false, xautolimits = false, yautolimits = false)\n\nfig","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MakieRepel","category":"page"},{"location":"#MakieRepel","page":"Home","title":"MakieRepel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MakieRepel is a re-implementation of ggrepel in Julia, for Makie!  Basically, it repels text from its associated point, the rest of the points in the axis, and from the axis sides.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: download-9)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Finding good parameters page to see how this works!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Eventually, this will all be wrapped in a recipe, but for now you need to do this by hand.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MakieRepel.repel_from_points","category":"page"}]
}
